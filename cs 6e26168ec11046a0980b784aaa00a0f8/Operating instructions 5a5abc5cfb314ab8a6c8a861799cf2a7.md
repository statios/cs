# Operating instructions

### 명령의 종류

오퍼랜드 + 명령 코드 = 명령

명령의 분류

- 연산에 관한 명령
    1. 산술 연산 명령
    2. 논리 연산 명령
    3. 시프트 연산 명령
- 연산 이외의 명령
    1. 데이터 전송 명령
    2. 입출력 명령
    3. 분기 명령
    4. 조건 판단(비교 명령 등)

### 산술 연산, 논리 연산 명령

**산술 연산의** 예는 **덧셈과 뺄셈**이 있으며, **논리 연산**의 예는 **AND(논리적), OR(논리화), NOT(부정)**이 있다. 이러한 산술 연산, 논리 연산을 하라는 명령이 산술 연산 명령, 논리 연산 명령이다. 

### 시프트 연산 명령

**시프트**는 모든 비트를 오른쪽 또는 왼쪽으로 일제히 동시에 이동한다는 뜻이다. 이러한 작업은 연산 결과를 일시적으로 기억하는 accumulator에서 처리된다. accumulator안에 시프트 기능이 있는 것이다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg)

이러한 시프트 연산을 이용해서 특정 나눗셈, 곱셈을 신속하게 할 수 있다. 위의 그림을 보면 2bit 오른쪽 시프트를 하는 경우에 원래 수의 1/4배가 되었다. 이처럼 시프트는 아래와 같은 특성을 가진다.

- N비트 왼쪽 시프트 → 원래의 2^n 배가된다.
- N비트 오른쪽 시프트 → 원래으 1/(2^n)배가 된다

### 부호 비트

**부호 비트** : 최상위 비트에서 양(0)이나 음(1)을 나타내는 비트. 그림처럼 최상위 비트로 부호를 나타내고 나머지 비트로 숫자를 나타낸다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-7.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-7.svg)

예를 들어 011은 +3을 나타내고 101은 -3을 나타낸다. 여기서 101이 왜 -3인지 이해가 가지 않을 것이다. 여기서 떠올려야 하는 것이 **보수** 개념이다. 보수는 2진수에 **음의 값을 나타낼 때** 보수 표현을 이용한다. 보수를 구하는 과정을 먼저 살펴보면.

1. 원래 수의 각 자리를 모두 반전한다 (0은 1로, 1은 0으로)
2. 반전한 수에 1을 더한다

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-8.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-8.svg)

이처럼 보통의 경우에는 3비트면 0~7까지의 8개 수를 나타내지만 부호 비트가 있는 경우에 3비트는 -4~3의 8개 수를 나타낸다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-9.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-9.svg)

예를 들어 101이라는 2진수가 있을 때 부호 비트가 있다고 생각하면 -3으로 해석할 수 있고, 부호 비트가 없다고 생각하면 5로 해석할 수 있다. 이때 가장 앞에 있는 비트가 부호 비트인지 아닌지 인간은 알 수 없지만 컴퓨터에는 그것을 구별할 수 있는 장치가 있다. 연산 결과에 의해 부호가 변화했을 때 부호를 알기 위한 플래그가 프로그램 안에 준비되어 있다. 이 플래그를 프로그램 안에서 감시함으로써 이상한 부호 변화가 있는지의 여부를 알 수 있는 것이다. 그러나 모든 CPU가 이 기능을 내장하고 있는 것은 아니며, 그럴 때는 프로그램으로 검출하는 과정을 거쳐야 한다.

### 논리 시프트와 산술 시프트

시프트 연산의 종류는 부호 비트의 유무에 따라 두가지가 있다.

1. 논리 시프트 → 부호 비트 없음
2. 산술 시프트 → 부호 비트 있음

왜냐하면 논리는 true/false 처럼 2가지 결과 값의 세계이다. 그러면 음수의 개념은 필요가 없는 것이다. 0과 1로 모든 것을 표현할 수 있으니까. 반면에 산술은 숫자를 다루게되므로 반드시 음수의 개념이 필요하다. 따라서 논리 시프트는 부호 비트를 고려할 필요가 없으므로 아래 그림처럼 단순하다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg)

반면에 산술 시프트는 최상위 비트인 부호 비트가 1이면 채우는 부분을 1로 채우고 0이면 0으로 채운다. 이렇게 산술 시프트는 부호 비트를 고려해야 한다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-10.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-10.svg)

또한 부호 비트가 0인 정수를 왼쪽으로 시프트했을 때 숫자 비트가 원래 부호 비트의 자리로 가게되면서 0이 아니라 1이 되버리는 경우가 있다. 음수이면서 부호 비트가 1이 되는 것이다. 왼쪽 시프트를 통해서 정수를 2^n배 하려고 했다가 부호가 반전 되버리는 경우다. 이것을 **overflow**라고 한다. 물이 넘친다는 뜻이다. 이 경우, 연산 결과가 취급할 수 있는 자릿수의 상한을 넘어버렸다는 의미다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-11.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-11.svg)

오버 플로우가 일어나면 스테이터스 레지스터 안의 오버플로 플래그(오버 플로 비트)가 설정된다. 연산의 결과 오버 플로가 일어났다는 것을 기억해 두는 것이다.

> 부동 소수점 연산에서는 연산 결과가 연산 알고리즘(계산 방법) 안에서 규정되어 있는 범위를 넘었을 때 오버 플로나 언더 플로가 발생한다. 예를 들어 연산 결과가 0.0000000...1이라는 한없이 0에 가까운 값이 되었을 때는 너무 작은 숫자라서 정확히 표현할 수 없다. 이것을 언더 플로(하위 자리 넘침)라고 한다. 그러나 여기서 설명하고 있는 것은 accumulator(register) 내부의 비교적 짧은 비트 열에 대한 정수값 연산의 취급에 관한 것이다. 정수값 연산과 부동 소수점 연산의 경우, 연산의 취급과 방식이 서로 다르다.

### 서큘러 시프트(로테이트 시프트)

circular는 원형이라는 의미고, rotate는 회전이라는 의미를 가진다. accumulator 속의 비트 열 양 끝이 연결된 이미지를 떠올리면 쉽다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-13.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-13.svg)

### 데이터 전송 명령

CPU(레지스터)와 메모리 사이에 행해지는 읽기와 쓰기 명령이다. 그리고 CPU내 레지스터끼리 데이터를 이동시키는 경우도 있다.

### 입출력 명령

CPU가 외부 장치와 데이터를 주고받기 위한 명령이다. 데이터의 입출력에는 I/O 포트를 사용한다.

### 분기 명령

다음에 실행해야 할 명령(프로그램)의 어드레스 번지로 점프하는 이미지를 연상하면 된다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-14.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-14.svg)

지금 실행하고 있는 명령의 어드레스 7번이지만, 7번 어드레스의 분기 명령으로 인해 다음은 15번으로 점프할 수도 있고, 거꾸로 3번으로 점프할 수도 있는 것이다. 즉, 이 분기 명령(점프 명령)에 의해 프로그램의 흐름을 바꾸거나 혹은 제어하는 것이다.

또한 점프에는 무조건 점프와 조건 점프가 있다.

### 브랜치 명령, 점프 명령, 스킵 명령

분기를 나타내는 명령으로 브랜치, 점프, 스킵이라는 표현이 있는데, 각 단어의 사용법에 일반적인 정의는 없고 CPU 제조사에 따라 다르다. 다만 최근에는 다음과 같은 개념으로 이를 구분하여 사용하는 경우가 많다.

**브랜치(branch) 명령** : 지금 실행하고 있는 곳에서 그리 멀지 않은 앞이나 뒤의 어드레스로 분기한다.

**점프(jump) 명령** : 브랜치 명령보다 더 먼 어드레스로 분기한다.

**스킵(skip) 명령** : 바로 다음 명령을 실행하거나 그 명령만 실행하지 않고 건너뛴다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-15.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-15.svg)

### 조건 판단과 스테이터스 플래그

조건 판단(비교 명령)은 두가지 데이터를 비교하여 조건에 맞는지 여부를 판단하는 것이다.

**스에이터스 플래그** : ALU에서 스에이터스 출력부분이 있는데 연산 결과의 상태를 나타내는 것이다. 계산 결과 플러스값이 되었다든가 하는. 그러한 상태를 기억해두는게 스테이터스 플래그다. 플래그는 깃발이라는 뜻으로 1이냐 0이냐에 따라 어떤 일정한 상태를 기억하고 있다. 조건이 성립했을 때는 플래그가 세워져 1이라는 값을 갖게 된다.

플래그에는 여러 가지 종류가 있고 각각의 조건이 정해져 있다. 조건이 성립했을 때 플래그가 세워지는 (1이되는) 것이다. 이러한 플래그 하나의 조건, 또는 여러 개를 조합한 조건에 의해 판단이 행해지는 것이다. 

**스테이터스 레지스터** : 이러한 플래그(각각 1비트)들을 8비트나 16비트로 정리한 것. 

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-16.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-16.svg)

### 분기 명령과 조건 판단의 조합

분기 명령과 조건 판단을 조합하여 매우 유용한 명령을 만들 수 있다. 예를 들어 Jump On Minus라는 명령의 경우, 'accumulator의 값이 마이너스일 때 특정 address로 점프한다' 라는 로직을 수행할 수 있다. 다시말해 조건에 따라 프로그램의 실행 순서를 제어할 수 있는것이다. 이런 조합을 통해서 조건 점프, 조건 스킵, 조건 브랜치 등의 명령을 만들 수 있다. 이러한 명령으로 구현할 수 있는 것들은 다음과 같다

1. 조건별로 다른 프로그램을 실행한다
2. 조건에 따라 어떤 프로그램을 실행하지 않는다
3. 조건에 따라 출력 포트의 비트를 세트하거나 리셋할 수 있다.

    예를 들어 어떤 조건일 때 출력 포트에 연결된 램프를 켜거나 끄는 경우에 응용된다.

## 오퍼랜드의 종류

### 오퍼랜드의 수

명령은 명령 코드(opcode)와 오퍼 랜드(operand)로 이루어져있으며 명령 코드는 명령의 종류를 나타내고, 오퍼랜드는 연산하는 값 또는 어드레스를 말한다. 명령에 필요한 오퍼 랜드의 개수는 명령 코드에 따라 달라진다. 만약 명령이 더하기 연산을 하라는 Add일 때 오퍼랜드는 2개가 된다.

오퍼랜드는 주로 0개, 1개, 2개 중 하나이다. 즉 오퍼랜드가 없는 명령 코드도 존재한다. 예를 들어 accumulator set to 1 이라는 명령코드다. 이것은 accumulator의 모든 비트를 1로 하라는 명령 코드이다. 이처럼 오퍼랜드 0개 또는 1개로 연산을 하는 경우, 연산 대상은 그 시점의 accumulator인 경우가 많다. 

2개의 오퍼랜드가 어드레스로 되어있는 경우 각각의 오퍼랜드를 **소스 오퍼랜드**, **데스티네이션 오퍼랜드** 라고 한다.  이름에서도 알 수 있듯이 소스 오퍼랜드의 데이터를 바탕으로하여 연산 결과를 데스티네이션 오퍼랜드에 저장한다.

### 오퍼랜드의 다양한 형식

오퍼랜드

- 즉치 처리
- 어드레스 참조

어드레싱 모드 (어드레스 또는 오퍼랜드의 지정 방법)

1. 직접 어드레스 지정
2. 상대 어드레스 지정
3. 간접 어드레스 지정
4. 어드레스 수식

### 즉치 처리

즉치란 그대로 바로 사용할 수 있는 숫자 라는 뜻이다. 구체적인 숫자가 오퍼랜드에 기술되어 있는 것이다. 예를 들어 Add 2 라는 명령이 있을 때 2는 즉치 오퍼랜드다.

### 어드레스 참조

오퍼랜드가 어드레스인 케이스다. 오퍼랜드가 내부나 외부 메모리의 어드레스를 지정하고 있다. 예를 들어 '외부 메모리의 1번 데이터와 2번 데이터를 더하고 그 결과를 3번에 저장하시오'라는 명령은 다음과 같다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-17.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-17.svg)

1. 어드레스 1에서 데이터를 어큐뮬레이터로 호출한다.
2. 어드레스 2의 내용을 어큐뮬레이터에 가산한다.
3. 어큐뮬레이터의 내용을 어드레스 3에 격납한다.

### 어드레싱 모드

1. 직접 어드레스 지정

    오퍼랜드의 값이 그대로 직접 실효 어드레스(실제 처리 대상이 되는 데이터가 들어 있는 어드레스)로 되어 있는 방식이다. **절대 어드레스 지정**이라고도 한다.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-18.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-18.svg)

2. 상대 어드레스 지정

    오퍼랜드의 값과 프로그램 카운터의 값을 가산한 값이 실효 어드레스인 방식.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-19.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-19.svg)

3. 간접 어드레스 지정

    오퍼랜드의 장소가 어떤 레지스터를 가리키고 있을 때 그 레지스터의 내용을 실효 어드레스로서 데이터를 참조하는 방식.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-20.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-20.svg)

4. 어드레스 수식

    수식 레지스터에 들어 있는 값을 수식하는 숫자로 이용하는 방식이다. 수식하는 원래 값(기준 값이 들어 있는 레지스터 값, 프로그램 카운터의 값, 오퍼랜드의 즉치 값 등)과 수식 레지스터의 값을 가산(감산)함으로써 '실효 어드레스'를 얻을 수 있다.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-21.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-21.svg)

## ALU에서의 연산 구조