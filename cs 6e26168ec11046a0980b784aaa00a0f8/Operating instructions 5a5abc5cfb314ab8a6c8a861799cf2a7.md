# Operating instructions

### 명령의 종류

오퍼랜드 + 명령 코드 = 명령

명령의 분류

- 연산에 관한 명령
    1. 산술 연산 명령
    2. 논리 연산 명령
    3. 시프트 연산 명령
- 연산 이외의 명령
    1. 데이터 전송 명령
    2. 입출력 명령
    3. 분기 명령
    4. 조건 판단(비교 명령 등)

### 산술 연산, 논리 연산 명령

**산술 연산의** 예는 **덧셈과 뺄셈**이 있으며, **논리 연산**의 예는 **AND(논리적), OR(논리화), NOT(부정)**이 있다. 이러한 산술 연산, 논리 연산을 하라는 명령이 산술 연산 명령, 논리 연산 명령이다. 

### 시프트 연산 명령

**시프트**는 모든 비트를 오른쪽 또는 왼쪽으로 일제히 동시에 이동한다는 뜻이다. 이러한 작업은 연산 결과를 일시적으로 기억하는 accumulator에서 처리된다. accumulator안에 시프트 기능이 있는 것이다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg)

이러한 시프트 연산을 이용해서 특정 나눗셈, 곱셈을 신속하게 할 수 있다. 위의 그림을 보면 2bit 오른쪽 시프트를 하는 경우에 원래 수의 1/4배가 되었다. 이처럼 시프트는 아래와 같은 특성을 가진다.

- N비트 왼쪽 시프트 → 원래의 2^n 배가된다.
- N비트 오른쪽 시프트 → 원래으 1/(2^n)배가 된다

### 부호 비트

**부호 비트** : 최상위 비트에서 양(0)이나 음(1)을 나타내는 비트. 그림처럼 최상위 비트로 부호를 나타내고 나머지 비트로 숫자를 나타낸다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-7.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-7.svg)

예를 들어 011은 +3을 나타내고 101은 -3을 나타낸다. 여기서 101이 왜 -3인지 이해가 가지 않을 것이다. 여기서 떠올려야 하는 것이 **보수** 개념이다. 보수는 2진수에 **음의 값을 나타낼 때** 보수 표현을 이용한다. 보수를 구하는 과정을 먼저 살펴보면.

1. 원래 수의 각 자리를 모두 반전한다 (0은 1로, 1은 0으로)
2. 반전한 수에 1을 더한다

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-8.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-8.svg)

이처럼 보통의 경우에는 3비트면 0~7까지의 8개 수를 나타내지만 부호 비트가 있는 경우에 3비트는 -4~3의 8개 수를 나타낸다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-9.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-9.svg)

예를 들어 101이라는 2진수가 있을 때 부호 비트가 있다고 생각하면 -3으로 해석할 수 있고, 부호 비트가 없다고 생각하면 5로 해석할 수 있다. 이때 가장 앞에 있는 비트가 부호 비트인지 아닌지 인간은 알 수 없지만 컴퓨터에는 그것을 구별할 수 있는 장치가 있다. 연산 결과에 의해 부호가 변화했을 때 부호를 알기 위한 플래그가 프로그램 안에 준비되어 있다. 이 플래그를 프로그램 안에서 감시함으로써 이상한 부호 변화가 있는지의 여부를 알 수 있는 것이다. 그러나 모든 CPU가 이 기능을 내장하고 있는 것은 아니며, 그럴 때는 프로그램으로 검출하는 과정을 거쳐야 한다.

### 논리 시프트와 산술 시프트

시프트 연산의 종류는 부호 비트의 유무에 따라 두가지가 있다.

1. 논리 시프트 → 부호 비트 없음
2. 산술 시프트 → 부호 비트 있음

왜냐하면 논리는 true/false 처럼 2가지 결과 값의 세계이다. 그러면 음수의 개념은 필요가 없는 것이다. 0과 1로 모든 것을 표현할 수 있으니까. 반면에 산술은 숫자를 다루게되므로 반드시 음수의 개념이 필요하다. 따라서 논리 시프트는 부호 비트를 고려할 필요가 없으므로 아래 그림처럼 단순하다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-6.svg)

반면에 산술 시프트는 최상위 비트인 부호 비트가 1이면 채우는 부분을 1로 채우고 0이면 0으로 채운다. 이렇게 산술 시프트는 부호 비트를 고려해야 한다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-10.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-10.svg)

또한 부호 비트가 0인 정수를 왼쪽으로 시프트했을 때 숫자 비트가 원래 부호 비트의 자리로 가게되면서 0이 아니라 1이 되버리는 경우가 있다. 음수이면서 부호 비트가 1이 되는 것이다. 왼쪽 시프트를 통해서 정수를 2^n배 하려고 했다가 부호가 반전 되버리는 경우다. 이것을 **overflow**라고 한다. 물이 넘친다는 뜻이다. 이 경우, 연산 결과가 취급할 수 있는 자릿수의 상한을 넘어버렸다는 의미다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-11.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-11.svg)

오버 플로우가 일어나면 스테이터스 레지스터 안의 오버플로 플래그(오버 플로 비트)가 설정된다. 연산의 결과 오버 플로가 일어났다는 것을 기억해 두는 것이다.

> 부동 소수점 연산에서는 연산 결과가 연산 알고리즘(계산 방법) 안에서 규정되어 있는 범위를 넘었을 때 오버 플로나 언더 플로가 발생한다. 예를 들어 연산 결과가 0.0000000...1이라는 한없이 0에 가까운 값이 되었을 때는 너무 작은 숫자라서 정확히 표현할 수 없다. 이것을 언더 플로(하위 자리 넘침)라고 한다. 그러나 여기서 설명하고 있는 것은 accumulator(register) 내부의 비교적 짧은 비트 열에 대한 정수값 연산의 취급에 관한 것이다. 정수값 연산과 부동 소수점 연산의 경우, 연산의 취급과 방식이 서로 다르다.

### 서큘러 시프트(로테이트 시프트)

circular는 원형이라는 의미고, rotate는 회전이라는 의미를 가진다. accumulator 속의 비트 열 양 끝이 연결된 이미지를 떠올리면 쉽다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-13.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-13.svg)

### 데이터 전송 명령

CPU(레지스터)와 메모리 사이에 행해지는 읽기와 쓰기 명령이다. 그리고 CPU내 레지스터끼리 데이터를 이동시키는 경우도 있다.

### 입출력 명령

CPU가 외부 장치와 데이터를 주고받기 위한 명령이다. 데이터의 입출력에는 I/O 포트를 사용한다.

### 분기 명령

다음에 실행해야 할 명령(프로그램)의 어드레스 번지로 점프하는 이미지를 연상하면 된다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-14.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-14.svg)

지금 실행하고 있는 명령의 어드레스 7번이지만, 7번 어드레스의 분기 명령으로 인해 다음은 15번으로 점프할 수도 있고, 거꾸로 3번으로 점프할 수도 있는 것이다. 즉, 이 분기 명령(점프 명령)에 의해 프로그램의 흐름을 바꾸거나 혹은 제어하는 것이다.

또한 점프에는 무조건 점프와 조건 점프가 있다.

### 브랜치 명령, 점프 명령, 스킵 명령

분기를 나타내는 명령으로 브랜치, 점프, 스킵이라는 표현이 있는데, 각 단어의 사용법에 일반적인 정의는 없고 CPU 제조사에 따라 다르다. 다만 최근에는 다음과 같은 개념으로 이를 구분하여 사용하는 경우가 많다.

**브랜치(branch) 명령** : 지금 실행하고 있는 곳에서 그리 멀지 않은 앞이나 뒤의 어드레스로 분기한다.

**점프(jump) 명령** : 브랜치 명령보다 더 먼 어드레스로 분기한다.

**스킵(skip) 명령** : 바로 다음 명령을 실행하거나 그 명령만 실행하지 않고 건너뛴다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-15.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-15.svg)

### 조건 판단과 스테이터스 플래그

조건 판단(비교 명령)은 두가지 데이터를 비교하여 조건에 맞는지 여부를 판단하는 것이다.

**스에이터스 플래그** : ALU에서 스에이터스 출력부분이 있는데 연산 결과의 상태를 나타내는 것이다. 계산 결과 플러스값이 되었다든가 하는. 그러한 상태를 기억해두는게 스테이터스 플래그다. 플래그는 깃발이라는 뜻으로 1이냐 0이냐에 따라 어떤 일정한 상태를 기억하고 있다. 조건이 성립했을 때는 플래그가 세워져 1이라는 값을 갖게 된다.

플래그에는 여러 가지 종류가 있고 각각의 조건이 정해져 있다. 조건이 성립했을 때 플래그가 세워지는 (1이되는) 것이다. 이러한 플래그 하나의 조건, 또는 여러 개를 조합한 조건에 의해 판단이 행해지는 것이다. 

**스테이터스 레지스터** : 이러한 플래그(각각 1비트)들을 8비트나 16비트로 정리한 것. 

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-16.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-16.svg)

### 분기 명령과 조건 판단의 조합

분기 명령과 조건 판단을 조합하여 매우 유용한 명령을 만들 수 있다. 예를 들어 Jump On Minus라는 명령의 경우, 'accumulator의 값이 마이너스일 때 특정 address로 점프한다' 라는 로직을 수행할 수 있다. 다시말해 조건에 따라 프로그램의 실행 순서를 제어할 수 있는것이다. 이런 조합을 통해서 조건 점프, 조건 스킵, 조건 브랜치 등의 명령을 만들 수 있다. 이러한 명령으로 구현할 수 있는 것들은 다음과 같다

1. 조건별로 다른 프로그램을 실행한다
2. 조건에 따라 어떤 프로그램을 실행하지 않는다
3. 조건에 따라 출력 포트의 비트를 세트하거나 리셋할 수 있다.

    예를 들어 어떤 조건일 때 출력 포트에 연결된 램프를 켜거나 끄는 경우에 응용된다.

## 오퍼랜드의 종류

### 오퍼랜드의 수

명령은 명령 코드(opcode)와 오퍼 랜드(operand)로 이루어져있으며 명령 코드는 명령의 종류를 나타내고, 오퍼랜드는 연산하는 값 또는 어드레스를 말한다. 명령에 필요한 오퍼 랜드의 개수는 명령 코드에 따라 달라진다. 만약 명령이 더하기 연산을 하라는 Add일 때 오퍼랜드는 2개가 된다.

오퍼랜드는 주로 0개, 1개, 2개 중 하나이다. 즉 오퍼랜드가 없는 명령 코드도 존재한다. 예를 들어 accumulator set to 1 이라는 명령코드다. 이것은 accumulator의 모든 비트를 1로 하라는 명령 코드이다. 이처럼 오퍼랜드 0개 또는 1개로 연산을 하는 경우, 연산 대상은 그 시점의 accumulator인 경우가 많다. 

2개의 오퍼랜드가 어드레스로 되어있는 경우 각각의 오퍼랜드를 **소스 오퍼랜드**, **데스티네이션 오퍼랜드** 라고 한다.  이름에서도 알 수 있듯이 소스 오퍼랜드의 데이터를 바탕으로하여 연산 결과를 데스티네이션 오퍼랜드에 저장한다.

### 오퍼랜드의 다양한 형식

오퍼랜드

- 즉치 처리
- 어드레스 참조

어드레싱 모드 (어드레스 또는 오퍼랜드의 지정 방법)

1. 직접 어드레스 지정
2. 상대 어드레스 지정
3. 간접 어드레스 지정
4. 어드레스 수식

### 즉치 처리

즉치란 그대로 바로 사용할 수 있는 숫자 라는 뜻이다. 구체적인 숫자가 오퍼랜드에 기술되어 있는 것이다. 예를 들어 Add 2 라는 명령이 있을 때 2는 즉치 오퍼랜드다.

### 어드레스 참조

오퍼랜드가 어드레스인 케이스다. 오퍼랜드가 내부나 외부 메모리의 어드레스를 지정하고 있다. 예를 들어 '외부 메모리의 1번 데이터와 2번 데이터를 더하고 그 결과를 3번에 저장하시오'라는 명령은 다음과 같다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-17.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-17.svg)

1. 어드레스 1에서 데이터를 어큐뮬레이터로 호출한다.
2. 어드레스 2의 내용을 어큐뮬레이터에 가산한다.
3. 어큐뮬레이터의 내용을 어드레스 3에 격납한다.

### 어드레싱 모드

1. 직접 어드레스 지정

    오퍼랜드의 값이 그대로 직접 실효 어드레스(실제 처리 대상이 되는 데이터가 들어 있는 어드레스)로 되어 있는 방식이다. **절대 어드레스 지정**이라고도 한다.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-18.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-18.svg)

2. 상대 어드레스 지정

    오퍼랜드의 값과 프로그램 카운터의 값을 가산한 값이 실효 어드레스인 방식.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-19.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-19.svg)

3. 간접 어드레스 지정

    오퍼랜드의 장소가 어떤 레지스터를 가리키고 있을 때 그 레지스터의 내용을 실효 어드레스로서 데이터를 참조하는 방식.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-20.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-20.svg)

4. 어드레스 수식

    수식 레지스터에 들어 있는 값을 수식하는 숫자로 이용하는 방식이다. 수식하는 원래 값(기준 값이 들어 있는 레지스터 값, 프로그램 카운터의 값, 오퍼랜드의 즉치 값 등)과 수식 레지스터의 값을 가산(감산)함으로써 '실효 어드레스'를 얻을 수 있다.

    ![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-21.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-21.svg)

---

### 시리얼 전송과 패러렐 전송

데이터(디지털 신호)의 전송 방식

**시리얼 전송** - serial은 직렬이라는 의미로, 데이터를 1비트씩 순서대로 전송한다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram.svg)

**페럴렐 전송** - 패럴렐은 병렬이라는 의미로, 데이터를 몇 비트씩 또는 한꺼번에 전송한다.

![Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-2.svg](Operating%20instructions%205a5abc5cfb314ab8a6c8a861799cf2a7/Untitled_Diagram-2.svg)

**시프트 레지스터와 패럴렐 시리얼 변환**

논리 회로로 회로를 설계하는 경우, 기능 블록에 '시프트 레지스터'를 설치하는 것이 있다. 시프트 레지스터는 ALU 내부의 누적기 기능은 없으며, 단순히 '시프트 기능을 가진 레지스터'라고 할 수 있다.

이 시프트 레지스터를 응용하여 가장 널리 쓰이고 있는 것이 패럴렐(병렬)의(예를 들어 8비트)  데이터를 일정 주기로 오른쪽으로 시프트하면서 맨 오른쪽 데이터를 추출하여 시리얼(직렬) 전송에 사용하는 데이터로 변환하는 부분이다. 

(이 시리얼 전송 부분을 CPU의 기능으로 볼 것인지 I/O의 일부로 볼 것인지는 논의의 여지가 있지만, 이 책의 경우 주변과의 전송에 있어 메모리 이외의 부분에 관해서는 '입출력 장치'라는 관점에서 생각하고 CPU 자체의 블록으로서는 다루지 않기로 한다.

### 기본적인 레지스터 정리

**Accumulator(누적기)**

ALU의 연산 결과를 기억하는 레지스터. 연산 결과를 그 다음 연산에 바로 이용할 수 있는 구조로 되어 있다. 순서대로 계산(특히 덧셈)할 때 연산 결과에 다음 값을 더하는 기능에서 'Accumulation(누적)'의 어원을 찾을 수 있다.

**명령 레지스터 - 명령 디코더**

메모리에서 읽은 코드를 일단 래치하여 그 명령 코드를 번역하는 기능이다. '어떤 연산을 하는지' 뿐만 아니라 '무엇과 무엇을 연산의 대상으로 하는지'도 해석한다. 명령 코드의 기본의 되는 것은 ALU가 해석할 수 있는 명령뿐이므로 이 명령을 조합하여 한꺼번에 연속적으로 명령을 실행할 수 있도록 내부 프로그램으로 ALU를 제어하는것이 일반적이다.

**스테이터스 레지스터**

CPU는 연산 결과의 내용에 따라 프로그램의 순서를 바꾸거나 입출력을 제어한다. 이때 판단 기준으로 사용하는 것이 플래그다. 플래그 자체는 1비트에 불과하며, 이것을 8비트나 16비트로 만든 것을 스테이터스 레지스터라고 부른다. 

수식 레지스터(베이스 레지스터, 인덱스 레지스터)

특정 어드레싱 모드에서 필요한 레지스터다.

베이스 레지스터 - 명령에 따라 지정되는 오퍼랜드가 어떤 기준값에 대하여 설정될 때 그 기준값을 결정한다.

인덱스 레지스터 - 현재의 프로그램 카운터에 특정한 값을 추가할 때 오퍼랜드에 영향을 미치는 정수를 넣어두는 기능을 한다.

**TEMP 레지스터**

일시적으로 데이터를 피난, 기억시키기 위한 레지스터다. CPU에 따라 몇 개의 블록별로 여러 개가 준비되어 있는 것도 있다. 

**프로그램 카운터**

다음에 실행할 명령의 어드레스(번지)를 기억하고 있는 카운터(레지스터)이다. 모든 CPU에 반드시 내장되어 있다.

**스택 포인터**

마지막으로 조작한 스택 어드레스를 기억하고 있는 레지스터다.

### 기본적인 스테이터스 플래그 정리

CPU에는 연산 결과에 따라 세트되거나 리셋되는 '스테이터스 플래그(스테이터스 비트)'가 있다. CPU는 다음과 같은 플래그의 하나의 조건 또는 조합된 조건에 따라 다양한 조건 판단을 한다. 그리고 그 판단 결과에 따라 프로그램 분기 등의 처리가 행해진다.

**제로 플래그(Z 플래그)**

어큐뮬레이터의 내용(연산 결과)이 제로를 나타낸다. 비교를 위한 연산기를 갖고 있지 않는 경우는 비교 결과가 같은(EQ 플래그) 것으로 보는 기능도 있다.

**사인(부호) 플래그(S 플래그) 또는 네거티브 플래그(N 플래그)**

accumulator의 내용을 숫자로 봤을 때 음의 값이 되어 있다는 것을 나타낸다.

**캐리 플래그(C 플래그) 또는 오버 플로 플래그(OV 플래그)**

산술 가산 연산을 한 결과, 캐리(자리 올림)나 오버 플로(자리 넘침)가 발생한 것을 나타낸다. 시프트 연산에서 자리 넘침이 있을 때도 세트된다. 산술 감산 연산을 했을 때 보로(borrow, 자리 내림)가 발생하지 않을 때는 세트되지 않는다.

**Borrow 플래그**

뺄셈을 할 때 borrow 발생을 나타낸다. '캐리 플래그가 세트되지 않는다'로 대용되는 것이 많지만, 경우에 따라서는 borrow 플래그를 사용하기도 한다.

**GT 플래그 / LT 플래그**

greater than의 약자로 비교 결과가 '~보다 크다'를 나타낼 때 세트된다.

less than의 약자로 비교 결과가 '~보다 작다'를 나타낼 세트된다.

**ODD 플래그**

연산 결과에 1이 홀수 개 있는 것을 나타낸다.

**인터럽트 마스크**

인터럽트를 받아들일 것인지의 여부를 미리 설정한다. 세트해두면 이터럽트가 금지된다.

**인터럽트 플래그**

인터럽트가 발생한 것을 나타내는 플래그이다. 인터럽트를 금지하는 조건일 때도 인터럽트가 있다는 것을 플래그에 의해 나타낸다.

### Sleep 명령

프로그램의 흐름을 제어하는 명령은 점프 명령 외에도 'STOP'이나 'SLEEP' 등이 있다. Sleep 명령을 사용하면 일시적으로 동작을 멈추고 어떤 입력(인터럽트)이 있을 때까지 프로그램을 실행하지 않는 상태를 만들 수 있다.

CPU는 sleep 명령을 실행함으로써 동작 클록의 주파수를 지연시키거나 프로그램의 진행을 멈춰 동작전력의 소비를 절감할 수 있다. 일상적인 동작으로 복귀하고 싶을 때 장치의 임의의 버튼을 누르면 CPU에 인터럽트를 알려 인터럽트 프로그램을 기동시킨다.