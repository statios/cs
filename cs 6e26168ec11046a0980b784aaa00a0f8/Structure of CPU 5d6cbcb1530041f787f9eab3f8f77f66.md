# Structure of CPU

## 메모리와 CPU

### Address

메모리 속에는 어드레스가 있다. 메모리 안에는 프로그램과 데이터가 저장되어 있다. 그리고 저장 장소에 따라 어드레스가 할당되어 있는 것이다.

CPU가 직접 관리하고 있는 공간을 **어드레스 공간(메모리 공간)** 이라고 한다.

Address를 통해서 원하는 데이터를 번호로 지정할 수 있다. 따라서 CPU가 메모리에서 데이터나 프로그램을 호출할 때 해당 어드레스 번호만으로 가져올 수 있게 된다.

### Bus

bus는 컴퓨터 내 데이터의 통로라고 할 수 있다.

**Address bus** : address를 지정하는 버스

**Data bus** : data를 주고받는 버스

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus.png)

**External bus** : CPU와 외부 장치를 연결하는 버스

**Internal bus** : CPU 내부를 연결하는 버스

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-3.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-3.png)

**Multiplexer(MUX)** : 내부 버스의 내부에서 경로를 전환 시키는 장치.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-4.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-4.png)

### 버스 폭과 비트 수

버스는 데이터의 통로라고 했는데 구체적으로는 **신호선을 다발로 묶은 것**이라고 볼 수 있다. 신호선은 0이나 1이라는 전기 신호가 지나다니는 선이다. 또한 신호선은 가닥수에 따라 표현할 수 있는 숫자가 달라진다. 예를들어 4가닥의 신호선이 있으면 4자리(4비트)의 2진수를 나타낼 수 있다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-5.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-5.png)

결국 신호선의 가닥수=비트 수가 된다. 4가닥의 신호선이면, 0000부터 1111까지 16가지 수를 표현할 수 있는 것이다. 신호선의 가닥수(비트 수)를 **버스 폭** 이라고 부른다. 버스 폭이 넓을 수록(비트 수가 많을 수록) CPU의 처리 능력이 향상된다. 예를들어 한 번에 4비트의 연산을 처리하는 ALU의 모습을 보면, 데이터 버스 폭도 4비트라는 것을 알 수 있다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-6.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-6.png)

ALU의 처리 폭(예를 들어 64비트)에 따라 데이터 버스 폭을 맞추는 것이 합리적이라서 데이터 버스 폭도 결과적으로 64비트가 되는 경우가 많다. **64비트 CPU**라는 건 이런 의미를 담고 있다. CPU의 비트 수와 데이터 버스 폭이 반드시 일치하는 것은 아니다. 예를 들어 1982년경 16비트 CPU의 경우, ALU가 16비트인데 데이터 버스 폭이 8비트인 것도 있었다. 그렇기 때문에 CPU로 데이터를 불러들이려면 데이터 버스를 통해 메모리에서 2회 데이터를 거둬들여야 했다.

외부 버스 폭 → CPU와 메모리가 한 번에 데이터를 몇 비트 주고받을 수 있는지 결정

내부 버스 폭 → CPU 내부에서 한 번에 연산을 몇 비트 할 수 있는지 결정

어드레스 버스 폭 → 어드레스를 몇 비트로 지정할 수 있는지 결정

정리하면 CPU의 능력은 버스 폭으로 판단할 수 있으며 데이터 버스 폭은 넓을 수록 좋다.

어드레스 버스 폭은 어드레스를 몇 비트로 지정할 수 있는지 결정되는데 이에 따라 **어드레스 공간 크기**도 정해진다.  예를들어 어드레스 폭이 32비트라고 하면, 2^32인 약 40억개의 어드레스가 존재한다. 그리고 어드레스 버스 폭은 어느 정도의 메모리 용량을 다룰 수 있는가 하는 문제와도 연결된다. 간단하게 말하면 어드레스 버스 폭도 넓을 수록 좋다.

### 메모리 용량과 버스 폭

메모리의 용량과 버스 폭에 대하여 생각해보자.

다음 그림과 같이 하나의 어드레스에 1byte의 데이터가 할당되어 있다고 가정하자. 1바이트는 8비트로, 데이터의 크기를 나타내는 단위다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled.png)

이 경우 어드레스 공간(어드레스 버스 폭)이 12비트이면 2의 12승으로, 어드레스의 수는 4096이 된다. 하나의 어드레스에 1바이트의 데이터이므로 취급할 수 있는 메모리 용량의 상한은 4096byte = 약 4kbyte가 된다.

### R/W 제어

**Read** : 저장되어 있는 데이터를 추출하는 것.

**Write** : 데이터를 기록해서 저장.

Load/Store라는 표현도 있는데, R/W는 하드웨어 측면에서, L/S는 소프트웨어 측면에서 바라본 표현이다. R/W는 메모리에 대한 읽기/쓰기 이고, 읽은 데이터를 어디로 가져갈 것인지, 어디에 있는 데이터를 쓸 것인지에 대해서는 관여하지 않는다. 한편 Load는 메모리에서 읽은 데이터를 레지스터로 이동시킨다. Store는 레지스터에서 데이터를 이동시켜 메모리에 쓴다. 이처럼 L/S는 데이터의 흐름을 의식하고 있다.

**제어 신호 :** control bus를 통해서 read/write 등의 신호를 보내는데 이것을 제어 신호라고 한다. 예를 들어 '83번 데이터가 필요하다'라는 명령을 할 때 실제로는 어드레스 버스로 '83번' 이라는 신호를, 제어 버스로 'read'라는 제어 신호를를 전달한다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-7.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-7.png)

### I/O (input/output)

**I/O 제어(I/O 신호) :** 입력 장치는 키보드와 마우스가 있고, 출력 장치는 모니터와 프린터가 있다. 이러한 외부 장치를 작동시키기 위한 제어 신호

**I/O 포트(입출력 포트)** : 외부와 데이터 주기받기를 하는 현관 역할을 한다. 이 포트를 경유하여 CPU와 외부 장치가 직접 연결되어 있다. (일반적으로 디스플레이는 CPU와 직접 연결되어 있지 않다.)

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-8.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-8.png)

### 명령의 구성요소

**operand** : 연산 등의 대상이 되는 것 (오퍼랜드, 피연산자). 실제 데이터가 아닌 Address로 지정하는 경우도 있다.

**opcode** : CPU가 수행해야하는 동작 (동작 코드, 명령코드)

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-9.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-9.png)

### 레지스터

CPU 속의 메모장같은 간단한 기억 장치인 **레지스터**는 명령을 실행할 때 반드시 필요하다. 레지스터는 용도에 따라 여러가지 종류가 있다.

**Accumulator(누산기)** : 계산 전용 메모장 같은 것이고 연산에 반드시 이용한다

**범용 레지스터** : 계산 외에도 여러가지 작업에 이용하는 레지스터

**명령 레지스터** : 메모리에서 읽은 명령(프로그램)을 일단 저장해두기 위한 레지스터

예를들어 1번 데이터와 2번 데이터를 더하라는 명령은 다음과 같은 절차를 거친다. 데이터는 일단 한 번은 레지스터에 저장한다고 생각해야 한다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-10.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/bus-10.png)

1. 1번 address의 데이터 2를 accumulator에 저장
2. 2번 address의 데이터 98을 범용 레지스터에 저장
3. ALU에서 덧셈 연산 실행
4. 연산 결과 데이터인 100은 자동적으로 accumulator에 저장

## CPU의 명령 처리 동작

### 고전적 CPU의 구조

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process.png)

### CPU의 명령 처리 동작

**Program counter** : 모든 CPU에 반드시 있는 매우 중요한 장치이며 항상 다음에 실행할 명령의 Address를 기억하고 있다.  

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process-3.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process-3.png)

1. 다음 명령의 address를 계산한다
2. address register에 저장한다
3. 메모리에 전달한다

**명령 디코더** : 메모리에서 호출된 명령 코드를 연산 처리를 할 수 있도록 하드웨어 내부에서 전환하는 동작을 수행한다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process-4.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process-4.png)

1. 메모리에서 address가 지정된 명령을 cpu로 전달한다
2. 전달받은 명령을 우선 명령 레지스터에 저장한다
3. 명령 디코더로 전달하여 해독한다
4. 해돌 결과 명령어인 operand와 opcode를 알 수 있다

이후에는 해당 명령어를 accumulator를 이용하여 ALU에서 연산한다. 그 결과를 메모리나 레지스터에 저장하는 것이다. 명령 처리 과정을 정리하면 다음과 같다.

1. 명령 읽기(페치)
2. 명령 해독(디코드)
3. 명령 실행
4. 결과 쓰기 (다음 명령을 수행하기 위해 1번으로)

### Program counter

다음 명령의 address를 count하는 역할을 한다. count가 수행되는 trigger timming은 명령이 명령 레지스터에 저장 되었을 때다. 주의할 점은 program counter는 다음에 실행해야 할 명령의 어드레스를 count하는건 맞지만 address가 7번 다음에 갑자기 15번이 되거나 3번이 될 가능성도 있다는 것이다. 

프로그램에는 조건 판단에 의한 분기와 반복이 있기 때문이다. 분기 또는 반복에 의해서 실행해야 할 명령의 address 번지수는 값이 점프하게 된다. 

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process-7.png](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/cpu_process-7.png)

이러한 분기나 반복을 실현하기 위해서 program counter는 다음에 count하는 address를 분기나 반복에 따른  address로 바꿔 쓴다. 즉 처리할 명령을 address에 대하여 순차적으로 하는 것이 아니라 program counter에 의해 적절한 address로 변경되어 명령을 수행하게된다. 

또한 기본적으로 program counter의 비트 수(pc가 나타내는 address의 비트 수)는 address bus의 비트 수와 동일하고 address 공간의 비트 수와도 동일하다.

컴퓨터에서 사용되는 cpu의 경우, os에서 실행되는 응용 프로그램에서는 address counter의 비트 수를 프로그래머가 신경 쓸 필요가 없다. 실제로 이용하는 메모리를 어떻게 잃고 쓸 것인지(액세스)는 os에 따라 관리되는 가상 메모리라는 개념에 속한다. 이 가상 메모리와 실제 메모리를 대응시키고 있는 하드웨어를 MMU(memory mapping unit)라고 한다.

## 여러 가지 기억 장치

**Main memory(주 기억 장치) :** 메모리

**보조 기억 장치 :** 하드디스크, SSD

메모리는 책상, 하드디스크는 서랍이라고 생각하자. 책상이 넓으면(메모리 용량이 크면) 동시에 많은 작업을 할 수 있다. 서랍이 크면(하드디스크 용량이 크면) 많은 것을 저장할 수 있다. CPU는 이러한 책상에 앉아서 업무를 하는 사람이라고 생각하면 적절한 비유가 될것이다.

1. 전원을 끄면 메모리에 있는 데이터는 사라지지만 하드디스크에 있는 데이터는 유지된다
2. 메모리는 CPU에서 직접 읽고 쓸 수 있지만 하드디스크는 직접 읽고 쓸 수 없다.

    ![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram.svg)

    CPU가 하드디스크의 어드레스를 직접 조작하고 있는 것은 아니다. CPU는 I/O 영역이라는 곳에 있는 '하드디스크 인터페이스'에 제어 신호를 보내고, 이 하드디스크 인터페이스가 하드디스크를 관리하고 있다. 다시말해 CPU와 바로 주고받을 수 있는 건 메모리와 I/O 뿐이다.

3. 메모리가 하드디스크에 비해 처리 속도가 빠르다.

    ![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-2.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-2.svg)

    CPU에 가까울수록 처리 속도는 빠르고 용량은 작다. CPU에서 멀어질수록 처리 속도는 느리고 용량은 크다.

### RAM 영역, ROM 영역, I/O 영역

Address 공간(memory 공간)이란 CPU가 직접 관리하고 있는 공간이다. 

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-3.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-3.svg)

좀 더 정확히 말하면 **Address 공간**(memory 공간)이란 **CPU가 관리하는 외부 메모리의 영역 전체를 가리키는 것이다.** Address 공간에 연결되어 있는 외부 메모리는 **RAM(읽고 쓸 쑤 있는 메모리)과 ROM(읽기 전용 메모리)** 두 종류로 분류할 수 있다. 메모리 공간 속에는 **RAM 영역과 ROM 영역**이 있는 것이다.

**RAM - random access memory**

- 읽기, 쓰기가 가능하다
- 전원이
- ex. 메인 메모리

**ROM - read only memory**

- 읽기만 가능하다
- 전원이 꺼져도 데이터를 저장하고 있다
- ex. BIOS-ROM

PC 내 마더보드라는 것 안에 ROM이 있다. 그 ROM에는 BIOS(Basic Input/Output System)라는 가장 기초적인 프로그램이 들어 있다. BIOS는 전원이 들어온 직후에 PC 내부의 여러 가지 장치가 정상적인지 확인한다. 그리고 하드디스크 속의 OS를 가동시켜 준다.

RAM 영역과 ROM 영역에 비해 매우 작은 영역이지만, 다음 그림과 같이 I/O 영역이라는 것이 있다. (I/O 영역은 메모리 공간에 없는 경우도 있다)

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-4.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-4.svg)

I/O는 입력/출력의 줄인말로 I/O 영역 안에는 I/O 포트(입출력 포트)가 들어있다. 이 I/O 포트를 경유해서 CPU와 외부 장치(키보드 등)가 직접 연결되어 있다. 키보드가 눌렀을 때 PC가 반응해 주는 건 이런 구조 덕분이다. Address 공간을 이용해서 외부 장치도 CPU의 관리하에 놓고 있는 것이다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-5.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-5.svg)

## Interrupt - 인터럽트

CPU가 어떤 계산 처리를 하고 있는 도중에도 마우스나 키보드를 움직이면 바로 반응하는 것은 인터럽트 기능 덕분이다. 또한 인터럽트 기능이 있기 때문에 본래 작업(계산 등)에도 집중할 수 있다. 예를 들어 CPU가 키보드를 눌렀는지 계속 관찰하지 않아도 된다. 그리고 인터럽트한 일이 정리되면 다시 원래 계산 작업으로 돌아갈 수 있게 하는 장치도 중요하다. 즉 계산 도중의 숫자나 프로그램 카운터의 값 등을 어딘가에 기억해두어야 한다는 것이다. 

### Stack & Stack Pointer

interrupt 작업이 끝난 후 다시 원래 작업으로 돌아가기 위해서 기억 메모가 필요하다. 이때 **스택**이라는 기능이 등장한다. 메인 메모리 속의 일부를 확보해두고 기억 장치로 사용하는 기능이다. 

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-6.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-6.svg)

데이터를 저장하는 것을 push라고 하고 데이터를 꺼내는 것을 pop이라고 한다. pop의 경우에는 가장 마지막에 push된 순서대로 데이터를 꺼낼 수 있다. 따라서 원하는 위치의 데이터를 추출할 수는 없다. 

Stack Pointer(SP)라는 register는 가장 마지막의 stack address를 기억한다. 

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-7.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-7.svg)

### 인터럽트의 우선도

**Interrupt mask** 기능을 사용하면 인터럽트를 받아들이지 않게 된다. 리셋은 mask를 하고 있어도 강제로 interrupt가 들어온다. 리셋은 가장 우선도가 높게 설정되어 있기 때문이다. 즉, 리셋은 마스크를 할 수 없는 특수한 인터럽트 입력이다. 전원을 켤 때 항상 리셋이 실행된다. 리셋은 프로그램을 초기화하는 역할을 하는데 바꿔말하면 내부 회로를 초기 상태로 되돌려주는 것이다. 그 덕분에 컴퓨터는 쾌적하게 눈을 뜨게 되고, 정상적으로 동작을 개시할 수 있게되는 것이다. 

우선순위가 가장 높은 인터럽트에 대해서는 마스크를 할 수 없는 구조로 되어 있는 CPU도 있다. 이렇게 마스크가 불가능한 인터럽트 입력을 NMI(Non Maskable Interrupt)라고 한다. 

**Timer Interrupt**는 카운트 다운하여 카운트가 0이 되었을 때 인터럽트를 발생시키는 것이다. 이것을 사용하면 일정한 간격으로 정해진 프로그램을 실행할 수 있게 된다. 

## 보충

### 메모리의 분류

- Rom - Read Only Memory
    - 메모리의 전원이 공급되지 않아도 내용을 계속 보유함 - 불휘발성 메모리
    - 읽기만 가능
- RAM - Random Access Memory
    - Address의 순서에 관계없이 무작위로 memory address를 지정
    - 읽기, 쓰기 가능
    - 휘발성 메모리

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-8.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-8.svg)

### I/O 포트와 GPU

input/output 장치와 CPU의 레지스터나 ALU가 연결되어 있지 않으면 외부에서의 입력을 CPU에 전달할 수 없다. 따라서 외부 메모리를 연결하는 것과 같은 방식으로 내부 버스를 입출력 포트를 통해 외부의 장치와 접속하는 것이다.

모니터는 일반적으로 CPU와 직접 접속되어 있지 않다. 디스플레이 부분은 GPU(Graphics Processing Unit)라는 화상 처리 전용 연산IC를 이용하여 화면을 표현한다. GPU를 사용하는 대규모 시스템용 CPU의 경우 GPU와의 전용 I/O포트를 갖추고 있다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-9.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-9.svg)

### 클록 주파수, 정확도

클록(클록 주파수)는 일정 주기로 H 레벨과 L 레벨을 반복하는 신호이다. 여기서 주파수란 1초당 반복하는 신호의 수를 뜻한다. 클록은 CPU에서 심장의 고동과 같은 역할을 담당하고 있다. 내부 회로(ALU에 데이터를 래치하거나 프로그램 카운터를 진행시키는 블록)를 가동하기 위해서는 클록이 필수이다. 

클록의 단위는 Hz(헤르츠)이고, 이것은 1초간 몇 회 클록 동작이 반복되고 있는지를 나타내는 값이다. 예를 들어 40MHz는 1초간 4,000만 회의 클록 동작이 반복되고 있다는 뜻이다. 

결국 CPU는 1클록마다 어떤 동작을 하고 있는 것이므로 Hz의 값이 높을수록 클록의 속도가 빨라 CPU의 처리 능력이 뛰어나다고 할 수 있다.

그리고 예를 들어 40MHz라는 주파수가 어느 정도나 엄밀하게 맞는지 그 정도를 나타내는 것을 정확도 라고 한다. 컴퓨터를 통신 기기에 응용하는 경우, 통신 기기끼리 연결하는 신호선은 서로 기준이 되는 클록이 일치하지 않으면 타이밍이 맞지 않게 된다.

### Clock generator - 클록 제너레이터

클록을 만들기 위한 회로(발진기)

일반적으로 **CPU의 내부**에 클록 제너레이터 블록이 내장되어 있는데, 외부에서 발진시킨 클록 신호를 이 블록에 입력할 수도 있다. CPU에 내장되어 있는 발진 회로는 부품을 조합하여 실현시키기 때문에 각 부품의 품질이 고르지 못하면 정확도가 떨어진다. 정확도가 낮은 클록을 사용하는 것이 허용되는 경우는 CPU의 한계까지 속도를 올리지 않아도 되는 경우나 다른 장치와 데이터를 주고받는 일이 그리 중요하지 않는 장치인 경우다.

외부 발진기의 경우 발진기로 만들어져 나오는 것이기 때문에 높은 정확도로 조정되어 있다. 따라서 통신 기기 등의 제어에 사용하는 경우, 통신에 이용하는 신호의 주파수의 정확도가 요구될 때는 외부 발진기를 사용하는 것이 바람직하다.

**수정 진동자**

클록 제너레이터는 신호를 증폭하는 회로(앰프)로 되어있다. 여기에 수정 진동자와 콘덴서(전기를 축적하거나 방출하는 전자 부품) 등을 접속함으로써 일정 주기의 신호를 만들어낸다. 

수정 진동자에는 수정편(인공 수정에서 잘라낸 매우 작고 얇은 수정 조각)이 들어 있다. 이 수정편에 2개의 전극을 달고 전압을 가하면 결정이 일그러진다. 전압의 방향을 2개의 전극 사이에서 교체하면 일정한 주기의 진동을 규칙적으로 일으킬 수 있는데, 이렇게 해서 정확한 시간의 간격을 만들어내는 것이다.

수정 진동자는 PC, 휴대 전화, 시계 등과 같이 정확한 시간의 간격을 필요로하는 다양한 제품에 사용되고 있다. 쿼츠 시계에서 '쿼츠'는 수정을 뜻한다.

### Timer interrupt - 타이머 인터럽트

CPU의 내부에 있는 감산 카운터를 이용하여 카운터의 값이 0이 되었을 때, 인터럽트를 발생시키는 기능

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-2%201.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-2%201.svg)

1. CPU의 명령으로 마스터 클록의 주기의 몇 배를 기준으로 할 것인지를 셀렉트 레지스터에 기록한다
2. 타이머 기준 클록을 몇 회 셀 때마다 인터럽트를 발생시킬 것인지를 초깃값 레지스터에 기록한다
3. 타이머 인터럽트를 가동시키는 trigger인 reset을 CPU의 명령으로 해제한다
4. 마스터 블록의 주기 * 셀렉트 레지스터 값 * 초깃값 레지스터 값 → 타이머 인터럽트 발생 주기

해당 기능을 이용하여 일정 간격으로 정해진 프로그램을 실행하는 것이 가능하다. 예를 들어 점멸 신호와 같이 on/off가 일정 간격으로 반복하는 경우, 감산 카운터는 다른 프로그램이 실행되는 중에도 수를 세어 인터럽트를 발생시킨다. 초깃값 레지스터 값이 100에서 50으로 변경되면 인터럽트 빈도는 2배가 된다.

위의 고전적 CPU의 개념도의 타이머 인터럽트 부분을 다시 살펴보자.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-3%201.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-3%201.svg)

**INT :** 타이머 인터럽트 블록에 대하여 CPU에서의 명령을 전달하기 위한 신호선

**RESET** : 타이머 인터럽트를 가동하는 trigger로 사용된다. 이 리셋을 활성화 상태로 두면 타이머는 동작하지 않으며, 타이머 리셋을 해제하면 타이머 인터럽트를 실행하게 돈다.

### 리셋 동작

프로그램을 초기화하여 내부 회로를 초기 상태로 만드는 것이다. 예를 들어 프로그램 카운터의 값은 0이 되고, 연산 도중의 데이터 등도 없어진다. 컴퓨터의 전원을 켜면 먼저 이 리셋이 실행된다. 리셋의 절차는 다음과 같다.

1. 전원을 켠 후 전원 전압이 안정될 때까지 리셋을 유효 상태로 둔다.

    (전원 전압이 불안정할 때 CPU가 동작을 개시하면 트러블 가능성이 있다)

2. 전원 전압이 안정되었을 때 리셋 입력을 높은 전압으로 끌어올려 리셋을 해제한다.

![Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-4%201.svg](Structure%20of%20CPU%205d6cbcb1530041f787f9eab3f8f77f66/Untitled_Diagram-4%201.svg)

### CPU의 능력을 결정하는 FLOPS 값

CPU의 능력을 결정하는 것은 CPU의 **클록 속도**와 **연산 속도**다. **클록 속도**는 ALU의 계산에 사용하는 논리 회로가 얼마나 빨리 작동할 수 있는지를 나타낸다. **연산 속도**는 얼마만큼의 속도로 연산을 실행할 수 있는지를 나타낸다.

고전적인 CPU는 ALU 블록이 수치 연산을 정수로 취급했다. 그래서 수치 연산의 속도보다는 오히려 '1초당 실행할 수 있는 명령의 수'인 MIPS(Million Inteructions Per Second)를 CPU 성능 지표로 사용했다. 1MIPS는 1초에 100만 회의 명령을 실행할 수 있다는 의미이다.

그 당시에도 프로그램의 개발에 의해 소수점이 붙은 수치를 계산했지만, 현재의 CPU는 부동 소수점 연산을 실행할 수 있는 하드웨어를 내장하고 있다. 따라서 현재는 '1초당 실행할 수 있는 부동 소수점 연산의 수'인 MFLOPS(Million Floating point number Operations Per Second)를 CPU 성능 지표로 사용한다. 1MFLOPS는 1초간 유효 숫자 15자리의 부동 소수점 연산을 100만회 실행할 수 있다는 의미이다.

MFLOPS보다 큰 단위로 GFLOPS나 TFLOPS가 있다. 1GFLOPS는 1초간 유효 숫자 15자리의 부동 소수점 연산을 10억 회, 1TFLOPS는 1조회 실행할 수 있다는 뜻이다.